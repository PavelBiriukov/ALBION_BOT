import pyautogui
import time

class Controller:
    def __init__(self, mouse_button="left"):
        self.mouse_button = mouse_button
        self.is_pressed = False
        self.last_action_time = time.time()

    def press(self):
        if not self.is_pressed:
            pyautogui.mouseDown(button=self.mouse_button)
            self.is_pressed = True
            self.last_action_time = time.time()

    def release(self):
        if self.is_pressed:
            pyautogui.mouseUp(button=self.mouse_button)
            self.is_pressed = False
            self.last_action_time = time.time()

    def reset(self):
        self.release()

        import cv2
import numpy as np
import mss
import toml

class Detector:
    def __init__(self, config):
        self.config = config
        self.sct = mss.mss()
        self.region = {
            "left": config["screen"]["region"][0],
            "top": config["screen"]["region"][1],
            "width": config["screen"]["region"][2],
            "height": config["screen"]["region"][3],
        }
        self.previous_position = None

    def grab(self):
        img = np.array(self.sct.grab(self.region))
        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

    def detect_indicator_position(self):
        img = self.grab()
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        
        # –ú–∞—Å–∫–∞ –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        mask_indicator = cv2.inRange(
            hsv,
            np.array(self.config["indicator"]["lower"]),
            np.array(self.config["indicator"]["upper"])
        )
        
        # –£–ª—É—á—à–∞–µ–º –º–∞—Å–∫—É
        kernel = np.ones((3, 3), np.uint8)
        mask_indicator = cv2.morphologyEx(mask_indicator, cv2.MORPH_CLOSE, kernel)
        mask_indicator = cv2.morphologyEx(mask_indicator, cv2.MORPH_OPEN, kernel)
        
        # –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ç—É—Ä—ã –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        contours, _ = cv2.findContours(mask_indicator, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        if contours:
            # –ë–µ—Ä–µ–º —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π –∫–æ–Ω—Ç—É—Ä
            largest_contour = max(contours, key=cv2.contourArea)
            
            # –ù–∞—Ö–æ–¥–∏–º —Ü–µ–Ω—Ç—Ä –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
            M = cv2.moments(largest_contour)
            if M["m00"] != 0:
                cx = int(M["m10"] / M["m00"])
                cy = int(M["m01"] / M["m00"])
                
                # –¶–µ–Ω—Ç—Ä –æ–±–ª–∞—Å—Ç–∏ –∑–∞—Ö–≤–∞—Ç–∞
                frame_center_x = self.region["width"] // 2
                
                # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
                debug_img = img.copy()
                cv2.drawContours(debug_img, [largest_contour], -1, (0, 255, 0), 2)
                cv2.circle(debug_img, (cx, cy), 5, (0, 0, 255), -1)
                cv2.line(debug_img, (frame_center_x, 0), (frame_center_x, self.region["height"]), (255, 0, 0), 2)
                
                cv2.imshow("Indicator Position", debug_img)
                cv2.waitKey(1)
                
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞
                position_relative_to_center = cx - frame_center_x
                return position_relative_to_center
        
        # –ï—Å–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
        cv2.imshow("Indicator Position", img)
        cv2.waitKey(1)
        return None

import cv2        
import toml
import time
from detector import Detector
from controller import Controller

def main():
    config = toml.load("config.toml")
    detector = Detector(config)
    controller = Controller(config["bot"]["mouse_button"])
    
    print("–ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã... –ü–µ—Ä–µ–∫–ª—é—á–∏—Å—å –≤ Albion!")
    time.sleep(3)
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    dead_zone = 10  # –ó–æ–Ω–∞ –Ω–µ—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (–ø–∏–∫—Å–µ–ª–µ–π)
    max_deviation = 100  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
    
    try:
        while True:
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞
            position = detector.detect_indicator_position()
            
            if position is not None:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–ª–æ–∂–µ–Ω–∏—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
                if position < -dead_zone:
                    # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–ª–µ–≤–∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ - –Ω–∞–∂–∏–º–∞–µ–º
                    controller.press()
                    print(f"PRESS (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–ª–µ–≤–∞: {position}px)")
                elif position > dead_zone:
                    # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–ø—Ä–∞–≤–∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ - –æ—Ç–ø—É—Å–∫–∞–µ–º
                    controller.release()
                    print(f"RELEASE (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–ø—Ä–∞–≤–∞: {position}px)")
                else:
                    # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤ —Ü–µ–Ω—Ç—Ä–µ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                    print(f"HOLD (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤ —Ü–µ–Ω—Ç—Ä–µ: {position}px)")
            else:
                # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω - –æ—Ç–ø—É—Å–∫–∞–µ–º –∫–Ω–æ–ø–∫—É
                controller.release()
                print("–ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω")
            
            time.sleep(config["bot"]["delay"])
            
    except KeyboardInterrupt:
        controller.reset()
        cv2.destroyAllWindows()
        print("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

if __name__ == "__main__":
    main()
    [screen]
region = [ 820, 520, 300, 150,]

[indicator]
lower = [ 12, 2, 196,]
upper = [ 32, 102, 255,]

[bot]
delay = 0.05
mouse_button = "left"

[control]
dead_zone = 10

/////////////////////////////////

import cv2
import numpy as np
import mss
import pyautogui
import time
import math


class RedColorDetector:
    def __init__(
        self,
        box_size=100,
        min_area=140,
        shake_threshold=10,
        cooldown=2,
    ):
        self.box_size = box_size
        self.min_area = min_area
        self.shake_threshold = shake_threshold
        self.cooldown = cooldown

        self.sct = mss.mss()
        self.prev_center = None
        self.last_bite_time = 0

    def _get_region(self):
        x, y = pyautogui.position()
        half = self.box_size // 2
        return {
            "left": max(0, x - half),
            "top": max(0, y - half),
            "width": self.box_size,
            "height": self.box_size
        }

    def grab(self):
        region = self._get_region()
        img = np.array(self.sct.grab(region))
        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

    def _detect_red_contour(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        lower1 = np.array([0, 120, 70])
        upper1 = np.array([10, 255, 255])
        lower2 = np.array([170, 120, 70])
        upper2 = np.array([180, 255, 255])

        mask = cv2.inRange(hsv, lower1, upper1) | cv2.inRange(hsv, lower2, upper2)

        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        for cnt in contours:
            if cv2.contourArea(cnt) < self.min_area:
                continue

            x, y, w, h = cv2.boundingRect(cnt)
            cx = x + w // 2
            cy = y + h // 2
            return (cx, cy), (x, y, w, h)

        return None, None

    def detect_bite(self, debug_frame=None):
        frame = self.grab()
        center, bbox = self._detect_red_contour(frame)

        bite = False

        if center and self.prev_center:
            dx = center[0] - self.prev_center[0]
            dy = center[1] - self.prev_center[1]
            dist = math.hypot(dx, dy)

            if (
                dist >= self.shake_threshold
                and time.time() - self.last_bite_time > self.cooldown
            ):
                bite = True
                self.last_bite_time = time.time()

        self.prev_center = center

        # ---- DEBUG ----
        if center and bbox:
            x, y, w, h = bbox
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
            cv2.circle(frame, center, 3, (255, 0, 0), -1)

        if bite:
            cv2.putText(
                frame,
                "BITE!",
                (5, 15),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                (0, 0, 255),
                2
            )

        cv2.imshow("Bite Detector", frame)
        cv2.waitKey(1)

        return bite

import cv2
import toml
import time
import pyautogui

from detector import Detector
from controller import Controller
from red_detector import RedColorDetector


def main():
    config = toml.load("config.toml")

    indicator_detector = Detector(config)          # –º–∏–Ω–∏-–∏–≥—Ä–∞
    controller = Controller(config["bot"]["mouse_button"])
    bite_detector = RedColorDetector(              # –ø–æ–∫–ª—ë–≤–∫–∞ (–∫—Ä–∞—Å–Ω—ã–π)
        box_size=100,
    )

    dead_zone = config["control"]["dead_zone"]

    print("–ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã... –ü–µ—Ä–µ–∫–ª—é—á–∏—Å—å –≤ Albion")
    time.sleep(3)

    try:
        while True:
            # ---------- –≠–¢–ê–ü 1: –ü–û–ö–õ–Å–í–ö–ê ----------
            if bite_detector.detect_bite():
                print("–ü–û–ö–õ–Å–í–ö–ê ‚Üí –ö–õ–ò–ö")
                pyautogui.click()
                time.sleep(0.5)  # –∂–¥—ë–º –ø–æ—è–≤–ª–µ–Ω–∏—è –º–∏–Ω–∏-–∏–≥—Ä—ã
                continue

            # ---------- –≠–¢–ê–ü 2: –ú–ò–ù–ò-–ò–ì–†–ê ----------
            position = indicator_detector.detect_indicator_position()

            if position is None:
                controller.release()
                time.sleep(config["bot"]["delay"])
                continue

            if position < -dead_zone:
                controller.press()
            elif position > dead_zone:
                controller.release()

            time.sleep(config["bot"]["delay"])

    except KeyboardInterrupt:
        controller.reset()
        cv2.destroyAllWindows()
        print("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")


if __name__ == "__main__":
    main()


_______________________________________

import cv2
import numpy as np
import mss
import time
import pyautogui


class WaterRedTest:
    def __init__(self):
        self.sct = mss.mss()
        monitor = self.sct.monitors[1]

        self.region = {
            "left": monitor["left"],
            "top": monitor["top"],
            "width": monitor["width"],
            "height": monitor["height"],
        }
        
        # –î–ª—è –Ω–∞–≤–µ–¥–µ–Ω–∏—è –º—ã—à–∫–∏
        self.last_red_position = None
        
        print("–ü–æ–∏—Å–∫ –∫—Ä–∞—Å–Ω–æ–≥–æ –¢–û–õ–¨–ö–û –≤–Ω—É—Ç—Ä–∏ –æ–∑–µ—Ä–∞")

    def grab(self):
        img = np.array(self.sct.grab(self.region))
        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

    def crop_game_area(self, frame):
        h, w, _ = frame.shape
        return frame[150:h - 200, 100:w - 300]

    def detect_water(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        lower_water = np.array([60, 20, 30])
        upper_water = np.array([140, 255, 255])

        mask = cv2.inRange(hsv, lower_water, upper_water)

        kernel = np.ones((7, 7), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not contours:
            return None

        cnt = max(contours, key=cv2.contourArea)
        if cv2.contourArea(cnt) < 20000:
            return None

        return cnt

    def detect_red_in_water(self, frame, water_contour):
        """–ù–∞—Ö–æ–¥–∏—Ç –∫—Ä–∞—Å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –¢–û–õ–¨–ö–û –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã"""
        # –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –≤–æ–¥—ã (–±–µ–ª–æ–µ –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç—É—Ä–∞, —á–µ—Ä–Ω–æ–µ —Å–Ω–∞—Ä—É–∂–∏)
        water_mask = np.zeros(frame.shape[:2], dtype=np.uint8)
        cv2.drawContours(water_mask, [water_contour], -1, 255, -1)
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ HSV –¥–ª—è –ª—É—á—à–µ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è —Ü–≤–µ—Ç–∞
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        
        # –î–∏–∞–ø–∞–∑–æ–Ω—ã –∫—Ä–∞—Å–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ –≤ HSV
        lower_red1 = np.array([0, 100, 50])      # –Ø—Ä–∫–æ-–∫—Ä–∞—Å–Ω—ã–π
        upper_red1 = np.array([10, 255, 255])
        lower_red2 = np.array([160, 100, 50])    # –¢–µ–º–Ω–æ-–∫—Ä–∞—Å–Ω—ã–π
        upper_red2 = np.array([180, 255, 255])
        
        # –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –∫—Ä–∞—Å–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
        red_mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
        red_mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
        red_mask = cv2.bitwise_or(red_mask1, red_mask2)
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å–∫—É –≤–æ–¥—ã - –¢–û–õ–¨–ö–û –∫—Ä–∞—Å–Ω–æ–µ –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã
        red_in_water_mask = cv2.bitwise_and(red_mask, water_mask)
        
        # –£–ª—É—á—à–∞–µ–º –º–∞—Å–∫—É –∫—Ä–∞—Å–Ω–æ–≥–æ
        kernel = np.ones((3, 3), np.uint8)
        red_in_water_mask = cv2.morphologyEx(red_in_water_mask, cv2.MORPH_CLOSE, kernel)
        red_in_water_mask = cv2.morphologyEx(red_in_water_mask, cv2.MORPH_OPEN, kernel)
        
        # –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω—Ç—É—Ä—ã –∫—Ä–∞—Å–Ω–æ–≥–æ –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã
        contours, _ = cv2.findContours(red_in_water_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º –∫–æ–Ω—Ç—É—Ä—ã –ø–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –ø–ª–æ—â–∞–¥–∏
        min_area = 25
        red_contours = []
        
        for contour in contours:
            area = cv2.contourArea(contour)
            if area > min_area:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç—É—Ä –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã
                # –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–Ω—Ç—É—Ä–∞
                contour_mask = np.zeros(frame.shape[:2], dtype=np.uint8)
                cv2.drawContours(contour_mask, [contour], -1, 255, -1)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –º–∞—Å–∫–æ–π –≤–æ–¥—ã
                intersection = cv2.bitwise_and(contour_mask, water_mask)
                
                # –ï—Å–ª–∏ –∫–æ–Ω—Ç—É—Ä –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã
                if np.count_nonzero(intersection) > area * 0.8:
                    red_contours.append(contour)
        
        return red_contours, red_in_water_mask
    
    def get_main_red_position(self, red_contours):
        """–ù–∞—Ö–æ–¥–∏—Ç —Ü–µ–Ω—Ç—Ä —Å–∞–º–æ–≥–æ –±–æ–ª—å—à–æ–≥–æ –∫—Ä–∞—Å–Ω–æ–≥–æ –∫–æ–Ω—Ç—É—Ä–∞ –í–ù–£–¢–†–ò –≤–æ–¥—ã"""
        if not red_contours:
            return None
        
        # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π –∫–æ–Ω—Ç—É—Ä (–ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –ø–æ–ø–ª–∞–≤–æ–∫)
        largest_contour = max(red_contours, key=cv2.contourArea)
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
        x, y, w, h = cv2.boundingRect(largest_contour)
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä
        center_x = x + w // 2
        center_y = y + h // 2
        
        return (center_x, center_y, w, h)
    
    def move_to_red(self, red_position):
        """–ü–µ—Ä–µ–º–µ—â–∞–µ—Ç –º—ã—à—å –Ω–∞ –∫—Ä–∞—Å–Ω—ã–π –ø–æ–ø–ª–∞–≤–æ–∫"""
        if red_position is None:
            return False
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –∫—Ä–∞—Å–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
            center_x, center_y, w, h = red_position
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –æ–±—Ä–µ–∑–∞–Ω–Ω–æ–≥–æ –∫–∞–¥—Ä–∞ –≤ –ø–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω
            screen_x = self.region["left"] + 100 + center_x  # 100 - left crop
            screen_y = self.region["top"] + 150 + center_y   # 150 - top crop
            
            # –ü–ª–∞–≤–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –º—ã—à–∏
            pyautogui.moveTo(screen_x, screen_y, duration=0.2)
            
            return True
            
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –º—ã—à–∏: {e}")
            return False

    def run(self):
        print("–¢–µ—Å—Ç –≤–æ–¥—ã + –∫—Ä–∞—Å–Ω–æ–≥–æ –ø–æ–ø–ª–∞–≤–∫–∞")
        print("–ö—Ä–∞—Å–Ω—ã–π –∏—â–µ—Ç—Å—è –¢–û–õ–¨–ö–û –≤–Ω—É—Ç—Ä–∏ –æ–±–ª–∞—Å—Ç–∏ –≤–æ–¥—ã")
        print("ESC ‚Äî –≤—ã—Ö–æ–¥, SPACE ‚Äî –≤–∫–ª/–≤—ã–∫–ª —Ç—Ä–µ–∫–∏–Ω–≥")
        
        frame_count = 0
        tracking_enabled = True

        while True:
            frame = self.grab()
            frame = self.crop_game_area(frame)
            debug = frame.copy()
            
            # –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –æ–±–ª–∞—Å—Ç–∏ –≤–æ–¥—ã
            water_area_display = np.zeros_like(frame)

            water = self.detect_water(frame)
            red_position = None
            
            if water is not None:
                # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –æ–±–ª–∞—Å—Ç—å –≤–æ–¥—ã
                cv2.drawContours(water_area_display, [water], -1, (100, 100, 255), -1)
                cv2.addWeighted(debug, 0.7, water_area_display, 0.3, 0, debug)
                
                # –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –≤–æ–¥—ã
                cv2.drawContours(debug, [water], -1, (255, 100, 0), 2)
                
                # –ò—â–µ–º –∫—Ä–∞—Å–Ω—ã–π –¢–û–õ–¨–ö–û –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã
                reds, red_mask = self.detect_red_in_water(frame, water)
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞—Å–∫—É –∫—Ä–∞—Å–Ω–æ–≥–æ –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã
                red_mask_display = cv2.cvtColor(red_mask, cv2.COLOR_GRAY2BGR)
                red_mask_display[:, :, 0] = 0  # –°–∏–Ω–∏–π –∫–∞–Ω–∞–ª = 0
                red_mask_display[:, :, 1] = 0  # –ó–µ–ª–µ–Ω—ã–π –∫–∞–Ω–∞–ª = 0
                # –ö—Ä–∞—Å–Ω—ã–π –∫–∞–Ω–∞–ª –æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å
                
                # –ù–∞–ª–æ–∂–µ–Ω–∏–µ –º–∞—Å–∫–∏ –∫—Ä–∞—Å–Ω–æ–≥–æ
                cv2.addWeighted(debug, 0.8, red_mask_display, 0.2, 0, debug)

                if reds:
                    # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π –∫—Ä–∞—Å–Ω—ã–π –æ–±—ä–µ–∫—Ç
                    red_position = self.get_main_red_position(reds)
                    
                    if red_position:
                        center_x, center_y, w, h = red_position
                        
                        # –†–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –≤–æ–∫—Ä—É–≥ –ø–æ–ø–ª–∞–≤–∫–∞
                        cv2.rectangle(debug, 
                                    (center_x - w//2, center_y - h//2),
                                    (center_x + w//2, center_y + h//2), 
                                    (0, 0, 255), 3)
                        
                        # –†–∏—Å—É–µ–º –∑–µ–ª–µ–Ω—ã–π –∫—Ä–µ—Å—Ç –≤ —Ü–µ–Ω—Ç—Ä–µ –ø–æ–ø–ª–∞–≤–∫–∞
                        cv2.drawMarker(debug, (center_x, center_y), 
                                     (0, 255, 0), cv2.MARKER_CROSS, 20, 2)
                        
                        # –†–∏—Å—É–µ–º –∂–µ–ª—Ç—ã–π –∫—Ä—É–≥ –≤ —Ü–µ–Ω—Ç—Ä–µ
                        cv2.circle(debug, (center_x, center_y), 8, (0, 255, 255), 2)
                        
                        # –ù–∞–≤–æ–¥–∏–º –º—ã—à–∫—É –Ω–∞ –ø–æ–ø–ª–∞–≤–æ–∫
                        if tracking_enabled:
                            success = self.move_to_red(red_position)
                            
                            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å —Ç—Ä–µ–∫–∏–Ω–≥–∞
                            status_text = "TRACKING: ON ‚úì" if success else "TRACKING: OFF"
                            status_color = (0, 255, 0) if success else (0, 0, 255)
                            cv2.putText(debug, status_text, (10, 30), 
                                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, status_color, 2)
                    
                    # –†–∏—Å—É–µ–º –≤—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∫—Ä–∞—Å–Ω—ã–µ –∫–æ–Ω—Ç—É—Ä—ã (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
                    for r in reds:
                        x, y, w, h = cv2.boundingRect(r)
                        cv2.rectangle(debug, (x, y), (x + w, y + h), (0, 165, 255), 1)
                        # –ú–∞–ª–µ–Ω—å–∫–∞—è —Ç–æ—á–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ –∫–∞–∂–¥–æ–≥–æ –∫–æ–Ω—Ç—É—Ä–∞
                        M = cv2.moments(r)
                        if M["m00"] > 0:
                            cx = int(M["m10"] / M["m00"])
                            cy = int(M["m01"] / M["m00"])
                            cv2.circle(debug, (cx, cy), 2, (0, 200, 255), -1)

            # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–∞ —ç–∫—Ä–∞–Ω–µ
            info_texts = [
                "ESC - Exit",
                f"Frame: {frame_count}",
                f"Tracking: {'ON' if tracking_enabled else 'OFF'}",
                f"Water found: {'Yes' if water is not None else 'No'}",
                f"Red in water: {'Yes' if red_position else 'No'}"
            ]
            
            y_offset = 60
            for text in info_texts:
                cv2.putText(debug, text, (10, y_offset), 
                          cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)
                y_offset += 25
            
            # –ï—Å–ª–∏ –ø–æ–ø–ª–∞–≤–æ–∫ –Ω–∞–π–¥–µ–Ω, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
            if red_position:
                center_x, center_y, w, h = red_position
                coord_text = f"Pop–ª–∞–≤–æ–∫: X:{center_x} Y:{center_y}"
                cv2.putText(debug, coord_text, (center_x + 10, center_y - 15),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
                
                area_text = f"–ü–ª–æ—â–∞–¥—å: {w*h}px"
                cv2.putText(debug, area_text, (center_x + 10, center_y + 5),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
            
            # –õ–µ–≥–µ–Ω–¥–∞ —Ü–≤–µ—Ç–æ–≤
            cv2.putText(debug, "–°–∏–Ω–∏–π: –æ–±–ª–∞—Å—Ç—å –≤–æ–¥—ã", (debug.shape[1] - 200, 30),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 100, 0), 1)
            cv2.putText(debug, "–ö—Ä–∞—Å–Ω—ã–π: –ø–æ–ø–ª–∞–≤–æ–∫", (debug.shape[1] - 200, 50),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
            cv2.putText(debug, "–ö—Ä–∞—Å–Ω–∞—è –º–∞—Å–∫–∞: –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ", (debug.shape[1] - 200, 70),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)

            cv2.imshow("Water + Red TEST (–¢–û–õ–¨–ö–û –≤ –≤–æ–¥–µ)", debug)
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à
            key = cv2.waitKey(1) & 0xFF
            if key == 27:  # ESC
                break
            elif key == 32:  # SPACE
                tracking_enabled = not tracking_enabled
                print(f"–¢—Ä–µ–∫–∏–Ω–≥ {'–≤–∫–ª—é—á–µ–Ω' if tracking_enabled else '–≤—ã–∫–ª—é—á–µ–Ω'}")
                time.sleep(0.2)

            frame_count += 1
            time.sleep(0.03)

        cv2.destroyAllWindows()
        print("\n–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω. –ö—Ä–∞—Å–Ω—ã–π –∏—Å–∫–∞–ª—Å—è –¢–û–õ–¨–ö–û –≤–Ω—É—Ç—Ä–∏ –≤–æ–¥—ã.")


if __name__ == "__main__":
    WaterRedTest().run()

_______________________________________
import cv2
import numpy as np
import mss
import pyautogui
import time
import math


class RedColorDetector:
    def __init__(
        self,
        box_size=100,
        min_area=140,
        shake_threshold=10,
        cooldown=2,
    ):
        self.box_size = box_size
        self.min_area = min_area
        self.shake_threshold = shake_threshold
        self.cooldown = cooldown

        self.sct = mss.mss()
        self.prev_center = None
        self.last_bite_time = 0

    def _get_region(self):
        x, y = pyautogui.position()
        half = self.box_size // 2
        return {
            "left": max(0, x - half),
            "top": max(0, y - half),
            "width": self.box_size,
            "height": self.box_size
        }

    def grab(self):
        region = self._get_region()
        img = np.array(self.sct.grab(region))
        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)

    def _detect_red_contour(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        lower1 = np.array([0, 120, 70])
        upper1 = np.array([10, 255, 255])
        lower2 = np.array([170, 120, 70])
        upper2 = np.array([180, 255, 255])

        mask = cv2.inRange(hsv, lower1, upper1) | cv2.inRange(hsv, lower2, upper2)

        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        for cnt in contours:
            if cv2.contourArea(cnt) < self.min_area:
                continue

            x, y, w, h = cv2.boundingRect(cnt)
            cx = x + w // 2
            cy = y + h // 2
            return (cx, cy), (x, y, w, h)

        return None, None

    def detect_bite(self, debug_frame=None):
        frame = self.grab()
        center, bbox = self._detect_red_contour(frame)

        bite = False

        if center and self.prev_center:
            dx = center[0] - self.prev_center[0]
            dy = center[1] - self.prev_center[1]
            dist = math.hypot(dx, dy)

            if (
                dist >= self.shake_threshold
                and time.time() - self.last_bite_time > self.cooldown
            ):
                bite = True
                self.last_bite_time = time.time()

        self.prev_center = center

        # ---- DEBUG ----
        if center and bbox:
            x, y, w, h = bbox
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
            cv2.circle(frame, center, 3, (255, 0, 0), -1)

        if bite:
            cv2.putText(
                frame,
                "BITE!",
                (5, 15),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.5,
                (0, 0, 255),
                2
            )

        cv2.imshow("Bite Detector", frame)
        cv2.waitKey(1)

        return bite   
_______________________________________

import cv2
import toml
import time

from detector import Detector
from controller import Controller
from fishing_bot import FishingBot
from fishing_caster import FishingCaster


def main():
    config = toml.load("config.toml")

    indicator = Detector(config)
    controller = Controller(config["bot"]["mouse_button"])

    bot = FishingBot()
    caster = FishingCaster()

    state = "SEARCH_WATER"

    print("üé£ –°—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã")
    time.sleep(3)

    try:
        while True:
            water = None
            if state != "MINI_GAME":
                frame = bot.grab()
                if frame is None:
                    continue
                frame = bot.crop_game_area(frame)
                water = bot.detect_water(frame)

            # ---------- –ü–û–ò–°–ö –í–û–î–´ ----------
            if state == "SEARCH_WATER":
                if water is not None:
                    caster.set_water_contour(water)
                    state = "CAST"
                    print("‚úÖ –í–æ–¥–∞ –Ω–∞–π–¥–µ–Ω–∞")

            # ---------- –ó–ê–ë–†–û–° ----------
            elif state == "CAST":
                if caster.simple_cast(bot.region):
                    bot.reset_tracking()
                    bot.float_found_time = time.time()
                    state = "WAIT_FLOAT"
                    print("üéØ –ó–∞–±—Ä–æ—Å –≤—ã–ø–æ–ª–Ω–µ–Ω")

            # ---------- –û–ñ–ò–î–ê–ù–ò–ï –ü–û–ü–õ–ê–í–ö–ê ----------
            elif state == "WAIT_FLOAT":
                reds, _ = bot.detect_red_in_water(frame, water)
                if reds:
                    bot.red_position = bot.get_main_red_position(reds)
                    bot.float_found_time = time.time()
                    state = "TRACK_BITE"
                    print("üî¥ –ü–æ–ø–ª–∞–≤–æ–∫ –Ω–∞–π–¥–µ–Ω")

            # ---------- –û–¢–°–õ–ï–ñ–ò–í–ê–ù–ò–ï –ü–û–ö–õ–Å–í–ö–ò ----------
            elif state == "TRACK_BITE":
                reds, _ = bot.detect_red_in_water(frame, water)
                if not reds:
                    bot.reset_tracking()
                    time.sleep(0.5)
                    state = "SEARCH_WATER"
                    bot.reset_tracking()
                    continue
                
                red_pos = bot.get_main_red_position(reds)
                screen_pos = bot.move_to_red(red_pos)

                if screen_pos:
                    bot.float_current_position = screen_pos

                    if bot.float_initial_position is None:
                        bot.float_initial_position = screen_pos
                        bot.float_found_time = time.time()
                        print("üìç –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ–ø–ª–∞–≤–∫–∞")

                    bite = bot.check_bite(screen_pos)
                    print("bite:", bite, "stable:", bot.float_stable)

                    if bite:
                        bot.hook_fish()
                        time.sleep(0.8)   # ‚Üê –£–í–ï–õ–ò–ß–ò–¢–¨
                        bot.skip_frames = 10   # ‚Üê –ù–û–í–û–ï

                        state = "MINI_GAME"
                        # ---------- –ú–ò–ù–ò-–ò–ì–†–ê ----------
            elif state == "MINI_GAME":
                position = indicator.detect_indicator_position()
            
                if position is None:
                    time.sleep(0.05)
                    continue   # ‚Üê –ñ–î–Å–ú, –ù–ï –í–´–•–û–î–ò–ú
                
                dead_zone = config["control"]["dead_zone"]
            
                if position < -dead_zone:
                    controller.press()
                elif position > dead_zone:
                    controller.release()

            time.sleep(0.03)

    except KeyboardInterrupt:
        controller.reset()
        cv2.destroyAllWindows()
        print("‚õî –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")


if __name__ == "__main__":
    main()

